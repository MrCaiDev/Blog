---
title: HTTP 状态码：1xx 信息性响应
description: HTTP 的 1xx 状态码代表信息性响应。通常不作为一次单独完整的交互，而是作为其它主要请求的辅助。
topic: http
createdAt: 2022/5/17
---

1xx 状态码在 HTTP/1.1 后才被引入，有可能会引起一些兼容性问题。因此，服务器、客户端和代理三方都需要遵守一些准则：

- 服务器：**禁止**向 HTTP/1.0 及以下的客户端发送 1xx 状态码。
- 客户端：在服务端的最终响应到达前，**必须**准备好应对若干个 1xx 响应，即使这不在客户端的意料之中。不过，用户代理**可能**忽略掉意料之外的 1xx 响应。
- 代理：**必须**转发 1xx 响应，除非这个 1xx 响应是代理自己要求的。

## 100 Continue

服务器接收到了客户端的先行请求，并且示意可以继续。

它一般用于以下场景：客户端想发给服务器一些数据，但不知道服务器愿不愿意接收，那么就需要通过一个先行请求进行询问。

下面从客户端、服务器、代理三方面来阐述其过程。

### 客户端

如果客户端想发送一个实体，并且想要避免“实体过大以至于服务器无法处理”的情况，那么就应当发送一个先行请求作为询问，并在请求头内携带 `Expect: 100-continue`，表示期望得到 100 Continue 的答复。如果没有实体要发送，就不应该携带这一字段，不然会让服务器误认为需要接收实体。

由于一些历史原因，客户端发送完这个先行请求之后，不能干等着 100 Continue；如果服务器超时未响应，客户端就无论如何都应该把实体直接发出去。

如果客户端在发完实体之后，才收到 100 Continue，就直接忽略。

### 服务器

在收到头部有 `Expect: 100-continue` 的请求后，服务器要么返回 100 Continue 表示同意，要么返回 417 Expectation Failed 表示拒绝。如果头部没有 `Expect: 100-continue`，那服务器**禁止**发送 100 Continue。

如果像客户端中后半段所述，客户端等不及了，直接发送了实体，那么服务器有可能在“来得及发送 100 Continue”之前就收到了实体。此时，服务器可以省略 100 Continue 响应，直接发送最终响应——比如 200 OK 表示成功，或者 413 Payload Too Large 表示实体过大。

### 代理

代理处于中间地位，所以它需要同时考虑双方兼容性问题。

- 当代理收到了客户端携带 `Expect: 100-continue` 的请求：

  - 如果它知道服务器在 HTTP/1.0 及以下，它就直接返回 417 Expectation Failed。
  - 否则，它就直接带着 `Expect: 100-continue` 转发该请求。

- 当代理收到了服务器的 100 Continue 响应：

  - 如果 `Expect: 100-continue` 是代理决定代表客户端添加的，那么它就禁止把 100 Continue 响应转发回客户端，而是自己决定怎么处理这个响应。
  - 否则，它必须把响应转发回客户端，即使客户端在 HTTP/1.0 及以下。

## 101 Switching Protocols

只在 HTTP/1.1 中出现。

服务器同意按客户端需求升级协议，比如从 HTTP/1.1 升级到 HTTP/2.0 或者 WebSocket。详细过程见 [MDN：协议升级机制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism)。

此响应的头部必须包含 `Connection: upgrade`，并且在 `Upgrade` 字段中标明升级到了哪个协议，如 `Upgrade: websocket`。

使用 1xx 状态码最常见的情景就是使用 WebSocket。事实上，当我们调用 API 建立 WebSocket 连接时，

```js
const conn = new WebSocket("ws://foo.bar");
```

`WebSocket()` 构造函数就已经自动完成了“发送初始 HTTP/1.1 请求、握手和升级”的一系列动作。
