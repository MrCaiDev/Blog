---
title: HTTP 缓存
description: 强缓存、协商缓存，以及其它的 Cache-Control。
topic: HTTP
createdAt: 2022/8/22
---

为 HTTP 文档设置合适的缓存，对于客户端和服务器都有巨大的好处：客户端可以省去等待网络请求的时间，服务器可以减轻处理请求的负荷。

## 强缓存

响应头使用 `Cache-Control: max-age=AGE` 指示强缓存的时长。

在收到响应后的这段时长内，客户端不再向服务器请求这份文档，而是直接复用本地缓存。在这段时长过后，客户端再重新发起请求。

这样做的优点是显而易见的：客户端不需要再发起请求，等待漫长的响应时间，从而**大幅提升加载速度**。

但是我们也很容易发现，**服务器完全失去了对客户端的控制**。这就对 `max-age` 的设置提出了很高的要求：如果设置的太长，那客户端就很容易看到过时的文档；如果设置的太短，那就相当于没缓存。

![HTTP强缓存](https://s2.loli.net/2022/08/23/NICJfXqH9rbp6hQ.webp)

## 协商缓存

协商缓存比较好地解决了这一矛盾。

在协商缓存中，强缓存过期后，客户端依然需要重新发起请求，但同时会携带一些凭证，告诉服务器：我手里的文档是什么样的。

服务器检查了这些凭证之后，会告诉客户端它手里的文档是否过期。如果没过期，客户端就可以刷新强缓存时长，并继续使用本地缓存。服务器也不用重发一遍文档。

![HTTP 协商缓存](https://s2.loli.net/2022/08/23/I5FkXqSGizgZUpK.webp)

### 基于日期的凭证

其中一种凭证基于文档的最后修改日期。它的原理很简单：**如果一份文档在我请求之后就没动过，那肯定可以直接用我的缓存。**

1. 在响应初次到达时，服务器通过 `Last-Modified` 字段告诉客户端：这份文档最后的修改日期是什么时候。
2. 客户端重新发起请求时，在 `If-Modified-Since` 字段携带这个日期。
3. 服务器检验文档是否在这个日期后被修改过。（比如使用 `fs.stat()`）
4. 如果未修改，服务器返回 304 Not Modified；如果否，返回 200 Success 与新文档。

这种方法相当简单直观，但是也有很多缺陷：

1. 日期的格式很复杂，难以解析。
2. 日期只能精确到秒。
3. 如果服务器只是重新保存了文档，那么即使内容没变，文件系统也会更新最后修改时间。

说完这三点，解决方案其实也显而易见了，就是让凭证基于文件的内容本身。

### 基于标签的凭证

服务器可以根据文档内容，为它生成一个标签，比如内容的哈希值或者版本号。之后，**如果标签未变，说明内容未变，客户端也就可以复用缓存**。

1. 在响应初次到达时，服务器通过 `ETag` 字段告诉客户端：这份文档的标签是多少。
2. 客户端重新发起请求时，在 `If-None-Match` 字段携带这个标签。
3. 服务器检验这个标签是否与自己手里的一致。
4. 如果一致，服务器返回 304 Not Modified；如果不一致，返回 200 Success 与新文档。

### Last-Modified 配合 ETag

当两种凭证同时出现时，`ETag` 优先级更高。

理论上，只要一个 `ETag` 就可以实现协商缓存；但 `Last-Modified` 还可以用于 CMS、爬虫等多个目的，所以一般两者会同时出现。

## 强缓存配合协商缓存

![强缓存与协商缓存配合使用](https://s2.loli.net/2022/08/23/DgKr2jbd6nxmlyV.webp)

从上图中，我们可以发现，强缓存与协商缓存并不是二选一的两种缓存手段，而是可以配合使用。

**如果缓存未过期，就使用强缓存；如果已过期，协商缓存与服务器协商是否更新缓存。**

## 其它 Cache-Control

Cache-Control 里用的最多的就是 max-age，但也有其它选项可选，互相配合使用。

### no-cache

明确禁止复用响应，客户端每次都必须从服务器请求最新文档。相当于是禁用了强缓存，然后靠协商缓存来验证是否过期。

> `Cache-Control: no-cache` 实现的效果与 `Cache-Control: max-age=0, must-revalidate` 相同。后者是 HTTP/1.1 之前的 workaround，现在直接用前者就可以。

_—— [MDN：Force Revalidation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#force_revalidation)_

### no-store

根本就不要保存任何响应。

实操中，`no-store` 大多可以使用 `no-cache` 或 `private` 替代，并达到相同的目的。

> 为了充分利用 Web 特性的优势，尽量使用 `no-cache` 与 `private` 的结合，而不是 `no-store`。

_—— [MDN：What's lost by no-store](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#whats_lost_by_no-store)_

### private / public

![按可见性划分HTTP缓存](https://s2.loli.net/2022/08/22/8mtBwe6cE5sVQqZ.webp)

- **私有缓存**：响应头携带 `Cache-Control: private`。通常用于缓存用户私密信息。
- **共享缓存**：响应头携带 `Cache-Control: public`。
  - **代理缓存**：中间代理可以缓存响应，但 HTTPS 下代理一般只扮演隧道角色。
  - **托管缓存**：如反向代理和 CDN，缓存主动权掌握在开发者手中。
